// const getAllCampaigns = async (
//   filters: IICampaignFilters,
//   paginationOptions: IPaginationOptions
// ) => {
//   const { searchTerm, ...filtersData } = filters;
//   const { page, limit, skip, sortBy, sortOrder } =
//     paginationHelpers.calculatePagination(paginationOptions);

//   const andConditions = [];

//   if (searchTerm) {
//     andConditions.push({
//       $or: CampaignSearchAbleFields.map(field => ({
//         [field]: {
//           $regex: searchTerm,
//           $options: 'i',
//         },
//       })),
//     });
//   }

//   if (Object.keys(filtersData).length) {
//     andConditions.push({
//       $and: Object.entries(filtersData).map(([field, value]) => ({
//         [field]: value,
//       })),
//     });
//   }

//   andConditions.push({
//     status: 'active',
//   });

//   const sortConditions: { [key: string]: SortOrder } = {};

//   if (sortBy && sortOrder) {
//     sortConditions[sortBy] = sortOrder;
//   }

//   const whereConditions =
//     andConditions.length > 0 ? { $and: andConditions } : {};

//   const result = await Campaign.find(whereConditions)
//     .populate({
//       path: 'user',
//       populate: {
//         path: 'brand',
//       },
//     })
//     .populate(['influencer', 'category'])
//     .sort(sortConditions)
//     .skip(skip)
//     .limit(limit);

//   const total = await Campaign.countDocuments();
//   return {
//     meta: {
//       page,
//       limit,
//       total,
//     },
//     data: result,
//   };
// };

// const updatedInfluencer = catchAsync(async (req: Request, res: Response) => {
//   const influencerId = req.params.id;
//   const influencerData = req.body;

//   let imagesToDelete = influencerData.imagesToDelete || [];
//   if (typeof imagesToDelete === 'string') {
//     try {
//       imagesToDelete = JSON.parse(imagesToDelete);
//     } catch (error) {
//       imagesToDelete = [imagesToDelete];
//     }
//   }

//   console.log('influencerData', influencerData);

//   const images = getFilePaths(req.files, 'images');

//   const value = {
//     image: images,
//     imagesToDelete: imagesToDelete,
//     ...influencerData,
//   };

//   const result = await InfluencerService.updateInfluencerToDB(
//     influencerId,
//     value
//   );

//   sendResponse(res, {
//     success: true,
//     statusCode: StatusCodes.OK,
//     message: 'Influencer updated successfully',
//     data: result,
//   });
// });

// invite

// const createInviteToDB = async (payload: Partial<IInvite>) => {
//   const isCampaignStatus = await Campaign.findOne({ _id: payload.campaign });

//   const approveStatus = isCampaignStatus?.approvalStatus;

//   const isUsers = isCampaignStatus?.user;

//   const isUser: any = await User.findById(isUsers);

//   payload.user = isUser._id;

//   if (isUser?.title === 'Silver' && isUser.subscription === true) {
//     // Verify that Collaborate documents have a field referencing the user
//     const invitationCount = await Invite.countDocuments({
//       user: isUser._id,
//     });

//     if (invitationCount >= 2) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Silver users can only create up to 2 collaborations.'
//       );
//     }
//   }

//   if (approveStatus === 'Rejected') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, your Campaign was Rejected you cannot invite new Influencers'
//     );
//   }

//   if (approveStatus !== 'Approved') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Campaign not approved yet, please wait for approval'
//     );
//   }

//   const invitationCount = await Invite.countDocuments({
//     user: isUser._id,
//   });

//   const isCampaign = await Campaign.findOne({ _id: payload.campaign }).populate(
//     'user',
//     'fullName'
//   );

//   // Check if the campaign exists and if user details are populated
//   if (!isCampaign || !isCampaign.user) {
//     throw new Error('Campaign or user not found');
//   }

//   //@ts-ignore
//   const fullName = isCampaign.user.fullName;

//   const result = await Invite.create(payload);

//   const data = {
//     text: `${fullName} invited you to join for events`,
//     receiver: payload.influencer,
//   };
//   await sendNotifications(data);

//   return { result, invitationCount };
// };

////////////////////////////////////////////////////////////////////

// const createInviteToDB = async (payload: Partial<IInvite>) => {
//   const isCampaignStatus = await Campaign.findOne({ _id: payload.campaign });

//   if (!isCampaignStatus) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign not found');
//   }

//   const approveStatus = isCampaignStatus?.approvalStatus;
//   const isUsers = isCampaignStatus?.user;

//   // Check if isUsers is a valid ID
//   if (!isUsers) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No user associated with the campaign'
//     );
//   }

//   const isUser: any = await User.findById(isUsers);

//   // Check if the user exists
//   if (!isUser) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'User not found');
//   }

//   payload.user = isUser._id;

//   if (isUser.title === 'Silver' && isUser.subscription === true) {
//     const startOfMonth = dayjs().startOf('month').toDate();
//     const endOfMonth = dayjs().endOf('month').toDate();

//     const invitationCount = await Invite.countDocuments({
//       user: isUser._id,
//       createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//     });

//     if (invitationCount >= 2) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Silver users can only create up to 2 collaborations.'
//       );
//     }
//   }

//   if (approveStatus === 'Rejected') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, your Campaign was Rejected you cannot invite new Influencers'
//     );
//   }

//   if (approveStatus !== 'Approved') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Campaign not approved yet, please wait for approval'
//     );
//   }

//   const isCampaign = await Campaign.findOne({ _id: payload.campaign }).populate(
//     'user',
//     'fullName'
//   );

//   // Check if the campaign exists and if user details are populated
//   if (!isCampaign || !isCampaign.user) {
//     throw new Error('Campaign or user not found');
//   }

//   //@ts-ignore
//   const fullName = isCampaign.user.fullName;

//   const result = await Invite.create(payload);

//   const startOfMonth = dayjs().startOf('month').toDate();
//   const endOfMonth = dayjs().endOf('month').toDate();
//   const invitationCount = await Invite.countDocuments({
//     user: isUser._id,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   // Send notification
//   const data = {
//     text: `${fullName} invited you to join for events`,
//     receiver: payload.influencer,
//   };
//   await sendNotifications(data);

//   return { result, invitationCount };
// };
/////////////////////////////////////////////////

// const createInviteToDB = async (payloads: Partial<IInvite>[]) => {
//   const results = await Invite.insertMany(payloads);

//   const populatedResults = await Invite.populate(results, {
//     path: 'influencer',
//     select: 'fullName',
//   });

//   const firstInfluencerName = (populatedResults[0].influencer as IInfluencer)
//     .fullName;

//   console.log(results);
//   console.log(firstInfluencerName);

//   if (results) {
//     const data = {
//       text: `${firstInfluencerName} invited you to join for events`,
//       receiver: payloads[0].influencer,
//     };
//     await sendNotifications(data);
//   }

//   return populatedResults;
// };

// const getAllInvites = async () => {
//   const result = await Invite.find()
//     .sort({
//       createdAt: -1,
//     })
//     .populate({
//       path: 'campaign',
//       select: 'image name startTime endTime',
//       populate: {
//         path: 'user',
//         select: 'fullName',
//         populate: {
//           path: 'brand',
//           select: 'owner',
//         },
//       },
//     })
//     .populate('influencer');
//   return result;
// };

//campaign
// const createCollaborationToDB = async (payload: ICollaboration) => {
//   const isInvite = await Invite.findById(payload.invite);
//   const inviteData = isInvite?.campaign;
//   const isCampaign = await Campaign.findById(inviteData);
//   const isInfluencer = await User.findById(payload.influencer);
//   const isUser = await User.findById(isCampaign?.user);

//   const isBrand = await Brand.findById(isUser?.brand);
//   const isCateory = await Category.findById(isBrand?.category);

//   if (!isCateory || !isBrand || !isCampaign) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       `${isBrand} ${isCampaign} ${isCateory} not found`
//     );
//   }

//   const isCategoryName = isCateory?.categoryName;
//   const value = {
//     categoryName: isCategoryName,
//     ...payload,
//   };

//   const result = await Collaborate.create(value);

//   const createInterestInfluencer = await Interest.create({
//     campaign: isCampaign,
//     influencer: result.influencer,
//     Collaborate: result._id,
//   });

//   if (!createInterestInfluencer) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to create interest with collaboration details'
//     );
//   }

//   //send notification
//   if (result) {
//     const data = {
//       text: `${isInfluencer?.fullName} accepted your invitation`,
//       receiver: isCampaign?.user,
//     };

//     await sendNotifications(data);

//     const bookingData = {
//       text: `${isInfluencer?.fullName} booked a new Collaboration`,
//       receiver: isCampaign?.user,
//       type: 'ADMIN',
//     };

//     await sendNotifications(bookingData);
//   }

//   return result;
// };

///

// const createCollaborationToDB = async (payload: ICollaboration) => {
//   const isInvite = await Invite.findById(payload.invite);

//   const inviteData = isInvite?.campaign;

//   const isCampaign = await Campaign.findById(inviteData);

//   const isInfluencer = await User.findById(payload.influencer);

//   const isUser = await User.findById(isCampaign?.user);

//   console.log(isUser);

//   if (isUser?.title === 'Silver' && isUser.subscription === true) {
//   }

//   const isBrand = await Brand.findById(isUser?.brand);

//   const isCateory = await Category.findById(isBrand?.category);

//   if (!isCateory || !isBrand || !isCampaign) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       `${isBrand} ${isCampaign} ${isCateory} not found`
//     );
//   }

//   const isCategoryName = isCateory?.categoryName;

//   const value = {
//     categoryName: isCategoryName,
//     ...payload,
//   };

//   const result = await Collaborate.create(value);

//   const createInterestInfluencer = await Interest.create({
//     campaign: isCampaign,
//     influencer: result.influencer,
//     Collaborate: result._id,
//   });

//   // const updateCampaign = await Campaign.findByIdAndUpdate(isCampaign._id, {
//   //   $push: { interest: result._id },
//   // });

//   // console.log(updateCampaign);

//   if (!createInterestInfluencer) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to create interest with collaboration details'
//     );
//   }

//   //send notification
//   if (result) {
//     const data = {
//       text: `${isInfluencer?.fullName} Accept your invitation`,
//       receiver: isCampaign?.user,
//     };

//     await sendNotifications(data);
//   }
//   if (result) {
//     const data = {
//       text: `${isInfluencer?.fullName} Booking a new Collaboration`,
//       receiver: isCampaign?.user,
//       type: 'ADMIN',
//     };

//     await sendNotifications(data);
//   }
//   //end notification

//   return result;
// };

//invite latest

// const createInviteToDB = async (payload: Partial<IInvite>) => {
//   const isCampaignStatus = await Campaign.findOne({ _id: payload.campaign });

//   if (!isCampaignStatus) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign not found');
//   }
//   console.log(isCampaignStatus);
//   const approveStatus = isCampaignStatus?.approvalStatus;
//   const isUsers = isCampaignStatus?.user;

//   if (!isUsers) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No user associated with the campaign'
//     );
//   }

//   const isUser: any = await User.findById(isUsers);

//   if (!isUser) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'User not found');
//   }

//   // payload.user = isUser._id;

//   if (isUser.title === 'Silver' && isUser.subscription === true) {
//     const startOfMonth = dayjs().startOf('month').toDate();
//     const endOfMonth = dayjs().endOf('month').toDate();

//     const userInvitationCount = await Invite.countDocuments({
//       campaign: payload.campaign,
//       createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//     });

//     if (userInvitationCount >= 2) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Silver users can only create up to 2 collaborations per month.'
//       );
//     }
//   }

//   if (approveStatus === 'Rejected') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, your campaign was rejected. You cannot invite new influencers.'
//     );
//   }

//   if (approveStatus !== 'Approved') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Campaign not approved yet. Please wait for approval.'
//     );
//   }

//   // Check if the campaign has reached its monthly invite limit
//   const startOfMonth = dayjs().startOf('month').toDate();
//   const endOfMonth = dayjs().endOf('month').toDate();

//   const campaignInviteCount = await Invite.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   if (campaignInviteCount >= 2) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Each campaign can only create up to 2 invites per month.'
//     );
//   }

//   const isCampaign = await Campaign.findOne({ _id: payload.campaign }).populate(
//     'user',
//     'fullName'
//   );

//   if (!isCampaign || !isCampaign.user) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign or user not found');
//   }

//   //@ts-ignore
//   const fullName = isCampaign.user.fullName;

//   const result = await Invite.create(payload);

//   const CampaignInviteCount = await Invite.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   // Send notification
//   const data = {
//     text: `${fullName} invited you to join for events`,
//     receiver: payload.influencer,
//   };
//   await sendNotifications(data);

//   return { result, CampaignInviteCount };
// };

// interest.service.ts
// const getAllInterest = async (userId: string, status?: string) => {
//   if (!userId) {
//     throw new ApiError(StatusCodes.BAD_REQUEST, 'User ID is required');
//   }

//   // Base filter conditions
//   const baseConditions: Record<string, any> = {};

//   // Add status filter if provided
//   if (status) {
//     baseConditions['status'] = status;
//   }

//   const allResults = await Interest.find(baseConditions)
//     .populate({
//       path: 'campaign',
//       populate: {
//         path: 'user',
//         select: 'fullName',
//       },
//     })
//     .populate({
//       path: 'influencer',
//       select: 'fullName',
//       populate: {
//         path: 'influencer',
//         select: 'fullName followersIG',
//       },
//     });

//   // Filter results by userId
//   const filteredResult = allResults.filter(
//     (item: any) => item.campaign && item.campaign.user._id.toString() === userId
//   );

//   if (filteredResult.length === 0) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'No data found');
//   }

//   const count = filteredResult.length;

//   return { result: filteredResult, count };
// };

// interest_influencer.service.ts
// const updatedInterestStautsToDb = async (
//   id: string,
//   payload: Partial<IInterest>
// ) => {
//   const updatedStatus = await Interest.findByIdAndUpdate(
//     id,
//     {
//       $set: {
//         status: payload.status,
//       },
//     },
//     {
//       new: true,
//       runValidators: true,
//     }
//   );

//   if (!updatedStatus) {
//     throw new Error('Interest not found');
//   }

//   const isInsterest = await Interest.findById(id);

//   const isCampaign = await Campaign.findById(isInsterest?.campaign);

//   const isUser = await User.findById(isCampaign?.user);

//   const collaborationId = updatedStatus.collaborate;

//   // send notifications
//   const influencerId = updatedStatus.influencer;

//   const influencerData = await User.findById(influencerId);

//   if (updatedStatus.status === 'Accepted') {
//     const data = {
//       text: `${isUser?.fullName} Accept your interest`,
//       receiver: influencerData,
//     };
//     await sendNotifications(data);
//   } else {
//     updatedStatus.status === 'Rejected';
//     const data = {
//       text: `${isUser?.fullName} Reject your interest`,
//       receiver: influencerData,
//     };
//     await sendNotifications(data);
//   }
//   // end notifications

//   if (updatedStatus.status === 'Accepted') {
//     const updateCollaboration = await Collaborate.findByIdAndUpdate(
//       collaborationId,
//       {
//         $set: {
//           typeStatus: 'Completed',
//         },
//       },
//       {
//         new: true,
//         runValidators: true,
//       }
//     );

//     return updateCollaboration;
//   } else if (updatedStatus.status === 'Rejected') {
//     const update = await Collaborate.findByIdAndUpdate(
//       collaborationId,
//       {
//         $set: {
//           typeStatus: 'Rejected',
//         },
//       },
//       {
//         new: true,
//         runValidators: true,
//       }
//     );

//     return update;
//   }

//   return updatedStatus;
// };

// invite
// const createInviteToDB = async (payload: Partial<IInvite>) => {
//   const isCampaignStatus = await Campaign.findOne({ _id: payload.campaign });

//   if (!isCampaignStatus) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign not found');
//   }
//   console.log(isCampaignStatus);
//   const approveStatus = isCampaignStatus?.approvalStatus;
//   const isUsers = isCampaignStatus?.user;

//   if (!isUsers) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No user associated with the campaign'
//     );
//   }

//   const isUser: any = await User.findById(isUsers);

//   if (!isUser) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'User not found');
//   }

//   // payload.user = isUser._id;

//   if (isUser.title === 'Silver' && isUser.subscription === true) {
//     const startOfMonth = dayjs().startOf('month').toDate();
//     const endOfMonth = dayjs().endOf('month').toDate();

//     const userInvitationCount = await Invite.countDocuments({
//       campaign: payload.campaign,
//       createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//     });

//     if (userInvitationCount >= 2) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Silver users can only create up to 2 collaborations per month.'
//       );
//     }
//   }

//   if (approveStatus === 'Rejected') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, your campaign was rejected. You cannot invite new influencers.'
//     );
//   }

//   if (approveStatus !== 'Approved') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Campaign not approved yet. Please wait for approval.'
//     );
//   }

//   // Check if the campaign has reached its monthly invite limit
//   const startOfMonth = dayjs().startOf('month').toDate();
//   const endOfMonth = dayjs().endOf('month').toDate();

//   const campaignInviteCount = await Invite.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   if (campaignInviteCount >= 2) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Each campaign can only create up to 2 invites per month.'
//     );
//   }

//   const isCampaign = await Campaign.findOne({ _id: payload.campaign }).populate(
//     'user',
//     'fullName'
//   );

//   if (!isCampaign || !isCampaign.user) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign or user not found');
//   }

//   //@ts-ignore
//   const fullName = isCampaign.user.fullName;

//   const result = await Invite.create(payload);

//   const CampaignInviteCount = await Invite.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   // Send notification
//   const data = {
//     text: `${fullName} invited you to join for events`,
//     receiver: payload.influencer,
//   };
//   await sendNotifications(data);

//   return { result, CampaignInviteCount };
// };

//

// const createInviteToDB = async (payload: Partial<IInvite>) => {
//   const isCampaignStatus = await Campaign.findOne({ _id: payload.campaign });

//   if (!isCampaignStatus) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign not found');
//   }

//   const approveStatus = isCampaignStatus.approvalStatus;
//   const isUsers = isCampaignStatus.user;
//   const collaborationLimit = isCampaignStatus.collaborationLimit as number; // Default to 2 if undefined

//   if (!isUsers) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No user associated with the campaign'
//     );
//   }

//   const isUser: any = await User.findById(isUsers);

//   if (!isUser) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'User not found');
//   }

//   if (approveStatus === 'Rejected') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, your campaign was rejected. You cannot invite new influencers.'
//     );
//   }

//   if (approveStatus !== 'Approved') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Campaign not approved yet. Please wait for approval.'
//     );
//   }

//   // Check if the campaign has reached its collaboration limit for the month
//   const startOfMonth = dayjs().startOf('month').toDate();
//   const endOfMonth = dayjs().endOf('month').toDate();

//   const campaignInviteCount = await Invite.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   if (campaignInviteCount >= collaborationLimit) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       `This campaign can only create up to ${collaborationLimit} invites per month.`
//     );
//   }

//   const isCampaign = await Campaign.findOne({ _id: payload.campaign }).populate(
//     'user',
//     'fullName'
//   );

//   if (!isCampaign || !isCampaign.user) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign or user not found');
//   }

//   //@ts-ignore
//   const fullName = isCampaign.user.fullName;

//   const result = await Invite.create(payload);

//   const CampaignInviteCount = await Invite.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   // Send notification
//   const data = {
//     text: `${fullName} invited you to join for events`,
//     receiver: payload.influencer,
//   };
//   await sendNotifications(data);

//   return { result, CampaignInviteCount };
// };

// invite
// const getAllInvitesForInfluencer = async (query: Record<string, unknown>) => {
//   const { searchTerm, page, influencerId, limit, ...filterData } = query;
//   const anyConditions: any[] = [];

//   // Step 1: Search for campaigns by category name
//   if (searchTerm) {
//     const campaignIds = await Campaign.find({
//       category: {
//         $in: await Category.find({
//           categoryName: { $regex: searchTerm, $options: 'i' },
//         }).distinct('_id'),
//       },
//     }).distinct('_id');

//     if (campaignIds.length > 0) {
//       anyConditions.push({ campaign: { $in: campaignIds } });
//     }
//   }

//   anyConditions.push({ influencer: influencerId });

//   // Step 2: Include other filter data
//   if (Object.keys(filterData).length > 0) {
//     const filterConditions = Object.entries(filterData).map(
//       ([field, value]) => ({
//         [field]: value,
//       })
//     );
//     anyConditions.push({ $and: filterConditions });
//   }

//   // Apply filter conditions
//   const whereConditions =
//     anyConditions.length > 0 ? { $and: anyConditions } : {};
//   const pages = parseInt(page as string) || 1;
//   const size = parseInt(limit as string) || 10;
//   const skip = (pages - 1) * size;

//   const result = await Invite.find(whereConditions)
//     .populate({
//       path: 'campaign',
//       // select: 'image name startTime endTime category',
//       populate: {
//         path: 'category',
//         select: 'categoryName',
//       },
//     })
//     .populate({
//       path: 'campaign',
//       select: 'image name startTime endTime category',
//       populate: {
//         path: 'user',
//         select: 'fullName',
//         populate: {
//           path: 'brand',
//           select: 'owner image',
//         },
//       },
//     })
//     .populate({
//       path: 'influencer',
//       select: 'fullName',
//     })
//     .sort({ createdAt: -1 })
//     .skip(skip)
//     .limit(size)
//     .lean();

//   const count = await Invite.countDocuments(whereConditions);

//   const data: any = {
//     result,
//     meta: {
//       page: pages,
//       total: count,
//     },
//   };
//   return data;
// };

///track
// const getAllTracks = async (influencerId: string) => {
//   const result = await Track.find({ influencer: influencerId }).populate({
//     path: 'campaign',
//     select: 'user image name',
//     populate: {
//       path: 'user',
//       select: 'brand',
//       populate: {
//         path: 'brand',
//         select: 'image owner',
//       },
//     },
//   });

//   if (!result) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Track not found');
//   }

//   return result;
// };

// track
// const getAllTrackForBrand = async (userId: string | undefined) => {
//   if (!userId) {
//     throw new ApiError(StatusCodes.BAD_REQUEST, 'UserId is required');
//   }

//   const allResults = await Track.find({})
//     .populate('influencer', 'fullName')
//     .populate({
//       path: 'campaign',
//       select: 'user image name',
//       populate: {
//         path: 'user',
//         select: 'brand',
//         populate: {
//           path: 'brand',
//           select: 'image owner',
//         },
//       },
//     });

//   const filteredResult = allResults.filter(
//     (item: any) => item.campaign && item.campaign.user._id.toString() === userId
//   );

//   if (filteredResult.length === 0) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'No data found');
//   }

//   const count = filteredResult.length;
//   if (!count) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'No data found');
//   }

//   return { result: filteredResult, count };
// };

//track

// const getAllTrackForBrand = async (
//   userId: string | undefined,
//   page: number = 1, // Default to page 1 if not provided
//   limit: number = 10 // Default to limit 10 if not provided
// ) => {
//   if (!userId) {
//     throw new ApiError(StatusCodes.BAD_REQUEST, 'UserId is required');
//   }

//   // Calculate skip and limit
//   const skip = (page - 1) * limit;

//   const allResults = await Track.find({})
//     .skip(skip) // Skip records for pagination
//     .limit(limit) // Limit the number of records per page
//     .populate('influencer', 'fullName')
//     .populate({
//       path: 'campaign',
//       select: 'user image name',
//       populate: {
//         path: 'user',
//         select: 'brand',
//         populate: {
//           path: 'brand',
//           select: 'image owner',
//         },
//       },
//     });

//   // Filter the results based on the userId
//   const filteredResult = allResults.filter(
//     (item: any) => item.campaign && item.campaign.user._id.toString() === userId
//   );

//   if (filteredResult.length === 0) {
//     return { result: [], count: 0 };
//   }

//   // Get the total count of matching items for pagination info
//   const count = filteredResult.length;

//   return { result: filteredResult, count };
// };

// const getAllTrackForBrand = async (userId: string | undefined) => {
//   const filter: any = {};

//   const result = await Track.find(filter)
//     .populate('influencer', 'fullName')
//     .populate({
//       path: 'campaign',
//       select: 'user image name',
//       populate: {
//         path: 'user',
//         select: 'brand',
//         populate: {
//           path: 'brand',
//           select: 'image owner',
//         },
//       },
//     });

//   const filteredResult = result.filter(
//     (item: any) => item.campaign && item.campaign.user.toString() === userId
//   );

//   const count = filteredResult.length;

//   if (!filteredResult.length) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'No data found');
//   }

//   return { result: filteredResult, count };
// };

//subscriptions
// const createCustomerAndSubscription = async (
//   email: string,
//   priceId: string,
//   user: string,
//   packages: string
// ) => {
//   try {
//     // Validate package existence
//     const packageData = await Package.findById(packages);
//     if (!packageData) {
//       throw new ApiError(StatusCodes.NOT_FOUND, 'Package not found');
//     }

//     // Create customer in Stripe
//     const customer = await stripe.customers.create({ email });

//     // Create subscription in Stripe
//     const subscription = await stripe.subscriptions.create({
//       customer: customer.id,
//       items: [{ price: priceId }],
//       payment_behavior: 'default_incomplete',
//       expand: ['latest_invoice.payment_intent'],
//     });

//     const priceAmount = subscription.items.data[0]?.price?.unit_amount ?? 0;
//     const price = priceAmount / 100;

//     const latestInvoice = subscription.latest_invoice;
//     if (!latestInvoice || typeof latestInvoice === 'string') {
//       throw new ApiError(StatusCodes.BAD_REQUEST, 'Invalid invoice data');
//     }

//     const paymentIntent = latestInvoice.payment_intent;
//     if (!paymentIntent || typeof paymentIntent === 'string') {
//       throw new ApiError(StatusCodes.BAD_REQUEST, 'Invalid payment intent');
//     }

//     // Save subscription data in DB
//     const newSubscription = await Subscribation.create({
//       subscriptionId: subscription.id,
//       status: subscription.status,
//       currentPeriodStart: formatDate(
//         new Date(subscription.current_period_start * 1000)
//       ),
//       currentPeriodEnd: formatDate(
//         new Date(subscription.current_period_end * 1000)
//       ),
//       priceAmount: price,
//       user,
//       packages,
//     });

//     // Update user subscription status
//     const updatedUser = await User.findByIdAndUpdate(
//       user,
//       { subscription: true, title: packageData.title },
//       { new: true }
//     );

//     if (!updatedUser) {
//       throw new ApiError(StatusCodes.BAD_REQUEST, 'Failed to update user');
//     }

//     return {
//       transactionId: paymentIntent.id,
//       subscriptionId: subscription.id,
//       clientSecret: paymentIntent.client_secret,
//       subscription: newSubscription,
//     };
//   } catch (error) {
//     console.error('Error creating subscription:', error);
//     throw new ApiError(
//       StatusCodes.INTERNAL_SERVER_ERROR,
//       'Failed to create subscription'
//     );
//   }
// };

// const getAllSubscriptationForBrand = async (brandId: string) => {
//   const result = await Subscribation.find({ user: brandId })
//     .populate({
//       path: 'user',
//       populate: {
//         path: 'brand',
//       },
//     })
//     .populate('packages');

//   const count = Subscribation.countDocuments();

//   return { result, count };
// };

// const updateustomerAndSubscription = async (
//   subscriptionId: string,
//   newPriceId: string
// ) => {
//   // Check if the subscriptionId exists in the database
//   const existingSub = await Subscribation.findOne({ subscriptionId });
// console.log(existingSub)
//   if (!existingSub) {
//     throw new Error('No subscription found with the provided subscriptionId.');
//   }

//   // Retrieve the subscription from Stripe
//   const subscription = await stripe.subscriptions.retrieve(subscriptionId);

//   if (!subscription) {
//     throw new Error('Subscription not found on Stripe.');
//   }

//   // Update the subscription on Stripe with the new priceId
//   const updatedSubscription = await stripe.subscriptions.update(
//     subscriptionId,
//     {
//       items: [
//         {
//           id: subscription.items.data[0].id, // Use the existing subscription item ID
//           price: newPriceId, // New plan/price ID
//         },
//       ],
//       proration_behavior: 'create_prorations', // Handles prorating the amount
//       expand: ['latest_invoice.payment_intent'],
//     }
//   );

//   // Retrieve the latest invoice and payment intent
//   const latestInvoice = updatedSubscription.latest_invoice;

//   if (!latestInvoice || typeof latestInvoice === 'string') {
//     throw new Error(
//       'Failed to update subscription; latest_invoice is missing or is invalid.'
//     );
//   }

//   const paymentIntent = latestInvoice.payment_intent;

//   if (!paymentIntent || typeof paymentIntent === 'string') {
//     throw new Error('Failed to retrieve payment intent from latest_invoice.');
//   }

//   // Update the local database with the new priceId and transaction information
//   existingSub.priceId = newPriceId; // Update the priceId
//   existingSub.transactionId = paymentIntent.id; // Update the transactionId
//   existingSub.clientSecret = paymentIntent.client_secret; // Update the clientSecret
//   await existingSub.save(); // Save the updated subscription data

//   const createSub = await Subscribation.create({
//     transactionId: paymentIntent.id,
//     subscriptionId: subscription.id,
//     clientSecret: paymentIntent.client_secret,
//   });

//   return {
//     transactionId: paymentIntent.id,
//     subscriptionId: updatedSubscription.id,
//     clientSecret: paymentIntent.client_secret,
//   };
// };

// const renewExpiredSubscriptions = async (
//   subscriptionId: string,
//   newPriceId?: string // Make newPriceId optional
// ) => {
//   // Find subscription record in the database
//   const subscriptionRecord = await Subscribation.findOne({ subscriptionId });

//   if (!subscriptionRecord) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       'Subscription not found in the database.'
//     );
//   }

//   // Check if the status is "expired"
//   if (subscriptionRecord.status !== 'expired') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Subscription is not expired and cannot be renewed.'
//     );
//   }

//   // Retrieve the existing subscription from Stripe
//   const stripeSubscription = await stripe.subscriptions.retrieve(
//     subscriptionId
//   );

//   // Check if the subscription is valid
//   if (!stripeSubscription || stripeSubscription.status !== 'active') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Invalid or inactive subscription.'
//     );
//   }

//   // Determine the price to use
//   const priceIdToUse = newPriceId || stripeSubscription.items.data[0].price.id;

//   // Retrieve the customer payment methods
//   const customerId =
//     typeof stripeSubscription.customer === 'string'
//       ? stripeSubscription.customer
//       : stripeSubscription.customer.id;

//   const paymentMethods = await stripe.paymentMethods.list({
//     customer: customerId,
//     type: 'card', // Adjust if you're using a different type of payment method
//   });

//   if (paymentMethods.data.length === 0) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'This customer has no attached payment source or default payment method.'
//     );
//   }

//   // Use the first payment method or set a default
//   const paymentMethodId = paymentMethods.data[0].id; // Get the first payment method

//   // Create a new subscription in Stripe
//   const newSubscription = await stripe.subscriptions.create({
//     customer: customerId, // Customer ID as a string
//     items: [{ price: priceIdToUse }],
//     default_payment_method: paymentMethodId, // Attach the payment method
//     expand: ['latest_invoice.payment_intent'], // Get the latest invoice details
//   });

//   // Update the subscription details in the database
//   const priceAmount = newSubscription.items.data[0]?.price?.unit_amount ?? 0;
//   const price = priceAmount / 100;

//   console.log(price);

//   // Save the new subscription record in the database
//   const newSubscriptionRecord = await Subscribation.create({
//     subscriptionId: newSubscription.id,
//     status: newSubscription.status,
//     priceAmount: price,
//     // Add other relevant fields from your subscription model
//   });

//   if (!newSubscriptionRecord) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to create new subscription record in the database.'
//     );
//   }

//   // Optionally, you might want to update the previous subscription record status to "canceled" or "renewed"
//   await Subscribation.findOneAndUpdate(
//     { subscriptionId },
//     { status: 'canceled' }, // Or however you want to handle the old subscription
//     { new: true }
//   );

//   return {
//     subscriptionId: newSubscription.id,
//     status: newSubscription.status,
//     newSubscriptionRecord,
//   };
// };

// const renewExpiredSubscriptions = async (
//   subscriptionId: string,
//   newPriceId?: string // Make newPriceId optional
// ) => {
//   // Find subscription record in the database
//   const subscriptionRecord = await Subscribation.findOne({ subscriptionId });

//   if (!subscriptionRecord) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       'Subscription not found in the database.'
//     );
//   }

//   // Check if the status is "expired"
//   if (subscriptionRecord.status !== 'expired') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Subscription is not expired and cannot be renewed.'
//     );
//   }

//   // Retrieve the existing subscription from Stripe
//   const stripeSubscription = await stripe.subscriptions.retrieve(
//     subscriptionId
//   );

//   // Check if the subscription is valid
//   if (!stripeSubscription || stripeSubscription.status !== 'active') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Invalid or inactive subscription.'
//     );
//   }

//   // Determine the price to use
//   const priceIdToUse = newPriceId || stripeSubscription.items.data[0].price.id;

//   // Retrieve the customer payment methods
//   const customerId =
//     typeof stripeSubscription.customer === 'string'
//       ? stripeSubscription.customer
//       : stripeSubscription.customer.id;

//   const paymentMethods = await stripe.paymentMethods.list({
//     customer: customerId,
//     type: 'card', // Adjust if you're using a different type of payment method
//   });

//   if (paymentMethods.data.length === 0) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'This customer has no attached payment source or default payment method.'
//     );
//   }

//   // Use the first payment method
//   const paymentMethodId = paymentMethods.data[0].id; // Get the first payment method

//   // Update the existing subscription in Stripe
//   const updatedSubscription = await stripe.subscriptions.update(
//     subscriptionId,
//     {
//       items: [
//         {
//           id: stripeSubscription.items.data[0].id, // Existing subscription item ID
//           price: priceIdToUse, // Use the new price ID or the existing one
//         },
//       ],
//       default_payment_method: paymentMethodId, // Attach the payment method
//       expand: ['latest_invoice.payment_intent'], // Get the latest invoice details
//     }
//   );

//   // Update the subscription details in the database
//   const priceAmount =
//     updatedSubscription.items.data[0]?.price?.unit_amount ?? 0;
//   const price = priceAmount / 100;

//   const updatedSub = await Subscribation.findOneAndUpdate(
//     { subscriptionId },
//     {
//       status: updatedSubscription.status,
//       priceAmount: price,

//       currentPeriodStart: formatDate(
//         new Date(updatedSubscription.current_period_start * 1000)
//       ),
//       currentPeriodEnd: formatDate(
//         new Date(updatedSubscription.current_period_end * 1000)
//       ),
//       // Add any other fields you want to update
//     },
//     { new: true }
//   );

//   if (!updatedSub) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to update subscription record in the database.'
//     );
//   }

//   return {
//     subscriptionId: updatedSubscription.id,
//     status: updatedSubscription.status,
//     updatedSub,
//   };
// };

//subscription updated
// const updateustomerAndSubscription = async (
//   newPriceId: string,
//   subscriptionId: string
// ) => {
//   // Check if the subscription exists in the database
//   const isExistSubId = await Subscribation.findOne({ subscriptionId });

//   if (!isExistSubId) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       'Subscription not found in the database.'
//     );
//   }

//   // Retrieve the existing subscription from Stripe
//   const subscription = await stripe.subscriptions.retrieve(subscriptionId);

//   if (!subscription) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       'Subscription not found in Stripe.'
//     );
//   }

//   if (subscription.status === 'incomplete') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Cannot update subscription in incomplete status. Finalize the payment first.'
//     );
//   }

//   // Update the subscription in Stripe with the new priceId
//   const updatedSubscription = await stripe.subscriptions.update(
//     subscriptionId,
//     {
//       items: [
//         {
//           id: subscription.items.data[0].id,
//           price: newPriceId,
//         },
//       ],
//       expand: ['latest_invoice.payment_intent'],
//     }
//   );

//   // Check if the latest_invoice and payment_intent exist in the updated subscription
//   const latestInvoice = updatedSubscription.latest_invoice;
//   if (!latestInvoice || typeof latestInvoice === 'string') {
//     throw new Error(
//       'Failed to update subscription; latest_invoice is missing or is invalid.'
//     );
//   }

//   const paymentIntent = latestInvoice.payment_intent;
//   if (!paymentIntent || typeof paymentIntent === 'string') {
//     throw new Error('Failed to retrieve payment intent from latest_invoice.');
//   }

//   // Update the subscription details in the database
//   const updatedSub = await Subscribation.findOneAndUpdate(
//     { subscriptionId },
//     {
//       // priceId: newPriceId, // Update to the new price ID

//       status: updatedSubscription.status,

//       currentPeriodEnd: formatDate(
//         new Date(updatedSubscription.current_period_end * 1000)
//       ),
//       currentPeriodStart: formatDate(
//         new Date(updatedSubscription.current_period_start * 1000)
//       ),
//     },
//     { new: true } // Return the updated document
//   );

//   if (!updatedSub) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to update subscription record in the database.'
//     );
//   }

//   return {
//     subscriptionId: updatedSubscription.id,
//     transactionId: paymentIntent.id,
//     clientSecret: paymentIntent.client_secret,
//     status: updatedSubscription.status,
//     updatedSub,
//   };
// };

// const cancelSubscription = async (subscriptionId: string) => {
//   // Check if the subscription exists in the database
//   const isExistSubId = await Subscribation.findOne({ subscriptionId });

//   if (!isExistSubId) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       'Subscription not found in the database.'
//     );
//   }

//   // Update the subscription to cancel at the end of the period
//   const updatedSubscription = await stripe.subscriptions.update(
//     subscriptionId,
//     {
//       cancel_at_period_end: true,
//     }
//   );

//   // Update the subscription details in the database
//   const updatedSub = await Subscribation.findOneAndUpdate(
//     { subscriptionId },
//     {
//       status: updatedSubscription.cancellation_details?.reason,

//       currentPeriodStart: formatDate(
//         new Date(updatedSubscription.current_period_start * 1000)
//       ),
//       currentPeriodEnd: formatDate(
//         new Date(updatedSubscription.current_period_end * 1000)
//       ),
//     },
//     { new: true }
//   );

//   if (!updatedSub) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to update subscription record in the database.'
//     );
//   }

//   return {
//     subscriptionId: updatedSubscription.id,
//     status: updatedSubscription.status,
//     updatedSub,
//   };
// };

// const renewExpiredSubscriptions = async (
//   subscriptionId: string,
//   newPriceId?: string // Make newPriceId optional
// ) => {
//   // Find subscription record in the database
//   const subscriptionRecord = await Subscribation.findOne({ subscriptionId });

//   if (!subscriptionRecord) {
//     throw new ApiError(
//       StatusCodes.NOT_FOUND,
//       'Subscription not found in the database.'
//     );
//   }

//   // Check if the status is "expired"
//   if (subscriptionRecord.status !== 'expired') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Subscription is not expired and cannot be renewed.'
//     );
//   }

//   // Retrieve the existing subscription from Stripe
//   const stripeSubscription = await stripe.subscriptions.retrieve(
//     subscriptionId
//   );

//   // Check if the subscription is valid
//   if (!stripeSubscription || stripeSubscription.status !== 'active') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Invalid or inactive subscription.'
//     );
//   }

//   // Prepare the customer ID
//   const customerId =
//     typeof stripeSubscription.customer === 'string'
//       ? stripeSubscription.customer
//       : stripeSubscription.customer?.id;

//   // Ensure a customer ID is available
//   if (!customerId) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No valid customer found for the subscription.'
//     );
//   }

//   let amountToCharge: number;
//   let currency: string;

//   if (newPriceId) {
//     // If a new price ID is provided, retrieve the new price details
//     const newPrice = await stripe.prices.retrieve(newPriceId);

//     // Ensure newPrice and its unit_amount are valid
//     if (!newPrice || newPrice.unit_amount === null) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Invalid new price ID or unit amount is null.'
//       );
//     }

//     amountToCharge = newPrice.unit_amount;
//     currency = newPrice.currency;
//   } else {
//     // If no new price ID, use the existing invoice
//     const latestInvoice = stripeSubscription.latest_invoice;
//     if (!latestInvoice || typeof latestInvoice === 'string') {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'No latest invoice found for the subscription.'
//       );
//     }

//     if (latestInvoice.amount_due === null) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Latest invoice amount_due is null.'
//       );
//     }

//     amountToCharge = latestInvoice.amount_due;
//     currency = latestInvoice.currency;
//   }

//   // Retrieve the default payment method
//   const paymentMethodId =
//     typeof stripeSubscription.default_payment_method === 'string'
//       ? stripeSubscription.default_payment_method
//       : undefined;

//   // Ensure paymentMethodId is valid
//   if (!paymentMethodId) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No valid payment method found for the subscription.'
//     );
//   }

//   // Create the payment intent
//   const paymentIntent = await stripe.paymentIntents.create({
//     amount: amountToCharge,
//     currency: currency,
//     customer: customerId,
//     // payment_method: 'Subscription creation',
//     payment_method: paymentMethodId,
//     off_session: true,
//     confirm: true,
//   });

//   // Check if the payment was successful
//   if (paymentIntent.status !== 'succeeded') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Payment failed. Please try again.'
//     );
//   }

//   const updatedSub = await Subscribation.findOneAndUpdate(
//     { subscriptionId },
//     {
//       status: 'active',
//       priceAmount: amountToCharge / 100,
//       currentPeriodStart: formatDate(new Date()),
//       currentPeriodEnd: formatDate(
//         new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
//       ),
//     },
//     { new: true }
//   );

//   if (!updatedSub) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to update subscription record in the database.'
//     );
//   }

//   return {
//     paymentIntentId: paymentIntent.id,
//     status: paymentIntent.status,
//     updatedSub,
//   };
// };

// show interst
// const createInviteForIncluencerToDB = async (
//   payload: Partial<IShowInterest>
// ) => {
//   // Check if the campaign has reached its monthly invite limit first
//   const startOfMonth = dayjs().startOf('month').toDate();
//   const endOfMonth = dayjs().endOf('month').toDate();

//   const campaignInviteCount = await ShowInterest.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   if (campaignInviteCount >= 2) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, you cannot send invite. The campaign limit is full!'
//     );
//   }

//   // Now check if the influencer has already shown interest
//   const isExistInfluencer = await ShowInterest.findOne({
//     influencer: payload.influencer,
//     campaign: payload.campaign,
//   });

//   if (isExistInfluencer) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Influencer already showed interest'
//     );
//   }

//   const isCampaignStatus = await Campaign.findOne({ _id: payload.campaign });

//   if (!isCampaignStatus) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign not found');
//   }

//   const approveStatus = isCampaignStatus?.approvalStatus;
//   const isUsers = isCampaignStatus?.user;

//   if (!isUsers) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'No user associated with the campaign'
//     );
//   }

//   const isUser: any = await User.findById(isUsers);

//   if (!isUser) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'User not found');
//   }

//   if (isUser.title === 'Silver' && isUser.subscription === true) {
//     const userInvitationCount = await ShowInterest.countDocuments({
//       campaign: payload.campaign,
//       createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//     });

//     if (userInvitationCount >= 2) {
//       throw new ApiError(
//         StatusCodes.BAD_REQUEST,
//         'Sorry, you cannot send invite. The campaign limit is full!'
//       );
//     }
//   }

//   if (approveStatus === 'Rejected') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Sorry, your campaign was rejected. You cannot invite new brands.'
//     );
//   }

//   if (approveStatus !== 'Approved') {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Campaign not approved yet. Please wait for approval.'
//     );
//   }

//   const isTrack = await Track.create({
//     influencer: payload.influencer,
//     campaign: payload.campaign,
//   });

//   if (!isTrack) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Track not found');
//   }

//   const isCampaign = await Campaign.findOne({ _id: payload.campaign }).populate(
//     'user',
//     'fullName'
//   );

//   if (!isCampaign || !isCampaign.user) {
//     throw new ApiError(StatusCodes.NOT_FOUND, 'Campaign or user not found');
//   }

//   //@ts-ignore
//   const fullName = isCampaign.user.fullName;

//   const result = await ShowInterest.create(payload);

//   const showInterestCount = await ShowInterest.countDocuments({
//     campaign: payload.campaign,
//     createdAt: { $gte: startOfMonth, $lte: endOfMonth },
//   });

//   // Send notification
//   const data = {
//     text: `${fullName} show interested in your campaign "${isCampaign.name}"`,
//     receiver: isUsers,
//   };
//   await sendNotifications(data);

//   return { result, showInterestCount };
// };

// interst
// const updatedInterestStautsToDb = async (
//   id: string,
//   payload: Partial<IInterestInfo>
// ) => {
//   const session = await mongoose.startSession();
//   session.startTransaction();

//   const Status = payload.status === 'Accepted' ? 'Completed' : 'Rejected';

//   try {
//     const updatedStatus = await InterestInfluencer.findByIdAndUpdate(
//       id,
//       {
//         $set: {
//           status: Status,
//         },
//       },
//       {
//         new: true,
//         runValidators: true,
//       }
//     );

//     if (!updatedStatus) {
//       throw new Error('Interest not found');
//     }

//     const isInsterest = await InterestInfluencer.findById(id);
//     const isCampaign = await Campaign.findById(isInsterest?.campaign);
//     const isUser = await User.findById(isCampaign?.user);

//     const collaborationId = updatedStatus.submitProve;
//     const trackId = updatedStatus.track;

//     // Send notifications
//     const influencerId = updatedStatus.influencer;
//     const influencerData = await User.findById(influencerId);

//     let data;
//     if (updatedStatus.status === 'Completed') {
//       data = {
//         text: `${isUser?.fullName} Accept your interest`,
//         receiver: influencerData,
//       };
//       await sendNotifications(data);
//     } else if (updatedStatus.status === 'Rejected') {
//       data = {
//         text: `${isUser?.fullName} Reject your interest`,
//         receiver: influencerData,
//       };
//       await sendNotifications(data);
//     }

//     // Now, only update collaboration and track based on specific statuses
//     if (
//       updatedStatus.status === 'Completed' ||
//       updatedStatus.status === 'Rejected'
//     ) {
//       const statusToUpdate = updatedStatus.status; // 'Completed' or 'Rejected'

//       // Update the collaboration and track status
//       const updateSubmitProve = await SubmitProve.findByIdAndUpdate(
//         collaborationId,
//         {
//           $set: {
//             typeStatus: statusToUpdate,
//           },
//         },
//         {
//           new: true,
//           runValidators: true,
//         }
//       );

//       // const updateTrack = await Track.findByIdAndUpdate(
//       //   trackId,
//       //   {
//       //     $set: {
//       //       status: statusToUpdate,
//       //     },
//       //   },
//       //   {
//       //     new: true,
//       //     runValidators: true,
//       //   }
//       // );

//       return {
//         updatedStatus,
//         updateSubmitProve,
//         // updateTrack,
//       };
//     }

//     return updatedStatus;
//   } catch (error) {
//     await session.abortTransaction();
//     throw error;
//   } finally {
//     // End session
//     session.endSession();
//   }
// };

//submitPRove
// const submitProveToDB = async (payload: ISubmitProve) => {
//   const trackId = payload.track;

//   const trackStatus = await Track.findById(trackId);

//   if (trackStatus?.status !== 'Accepted') {
//     throw new ApiError(StatusCodes.BAD_REQUEST, 'Track is not Accepted yet');
//   }

//   const isExistSubmitProve = await SubmitProve.findOne({
//     track: trackId,
//   });

//   if (isExistSubmitProve) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'You have already submitted prove for this track'
//     );
//   }

//   const isTrack = await Track.findById(trackId);

//   const isCampaign = await Campaign.findById(isTrack?.campaign);

//   const isInfluencer = await User.findById(isTrack?.influencer);

//   const isCategory = await Category.findById(isCampaign?.category);

//   const category = isCategory?.categoryName;

//   const value = {
//     categoryName: category,
//     ...payload,
//   };

//   const result = await SubmitProve.create(value);

//   const createInterestInfluencer = await InterestInfluencer.create({
//     campaign: isCampaign,
//     influencer: isInfluencer,
//     submitProve: result._id,
//     track: payload.track,
//   });

//   if (!createInterestInfluencer) {
//     throw new ApiError(
//       StatusCodes.BAD_REQUEST,
//       'Failed to create interestInfluencer with SubmitProve details'
//     );
//   }

//   if (result) {
//     const data = {
//       text: `accepted your invitation`,
//       receiver: isCampaign?.user,
//       name: isInfluencer?.fullName,
//     };

//     await sendNotifications(data);

//     const bookingData = {
//       text: `Submit new Prove`,
//       type: 'ADMIN',
//       name: isInfluencer?.fullName,
//     };

//     await sendNotifications(bookingData);
//   }
//   return result;
// };
